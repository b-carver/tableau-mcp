import { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { Ok } from 'ts-results-es';
import { z } from 'zod';

import { getConfig } from '../config.js';
import { useRestApi } from '../restApiInstance.js';
import { Server } from '../server.js';
import { Tool } from './tool.js';

// Hardcoded datasource LUID - replace with your actual datasource LUID
const HARDCODED_DATASOURCE_LUID = '71db762b-6201-466b-93da-57cc0aec8ed9';

export const getSearchQuery = (datasourceLuid: string): string => `
  query datasourceFieldInfo {
    publishedDatasources(filter: { luid: "${datasourceLuid}" }) {
      name
      description
      owner {
        name
      }
      fields {
        name
        isHidden
        description
        descriptionInherited {
          attribute
          value
        }
        fullyQualifiedName
        __typename
        ... on AnalyticsField {
          __typename
        }
        ... on ColumnField {
          dataCategory
          role
          dataType
          defaultFormat
          semanticRole
          aggregation
          aggregationParam
        }
        ... on CalculatedField {
          dataCategory
          role
          dataType
          defaultFormat
          semanticRole
          aggregation
          aggregationParam
          formula
          isAutoGenerated
          hasUserReference
        }
        ... on BinField {
          dataCategory
          role
          dataType
          formula
          binSize
        }
        ... on GroupField {
          dataCategory
          role
          dataType
          hasOther
        }
        ... on CombinedSetField {
          delimiter
          combinationType
        }
      }
    }
  }`;

const paramsSchema = {
    query: z.string().describe('Search query to find relevant fields and metadata in the datasource'),
};

export const getSearchTool = (server: Server): Tool<typeof paramsSchema> => {
    const searchTool = new Tool({
        server,
        name: 'search',
        description: 'Searches for resources using the provided query string and returns matching results.',
        paramsSchema,
        annotations: {
            title: 'Search',
            readOnlyHint: true,
            openWorldHint: true,
        },
        callback: async ({ query }, { requestId }): Promise<CallToolResult> => {
            const config = getConfig();
            const graphqlQuery = getSearchQuery(HARDCODED_DATASOURCE_LUID);

            return await searchTool.logAndExecute({
                requestId,
                args: { query },
                callback: async () => {
                    const result = await useRestApi(
                        config.server,
                        config.authConfig,
                        requestId,
                        server,
                        async (restApi) => {
                            return await restApi.metadataMethods.graphql(graphqlQuery);
                        },
                    );

                    // Filter results based on search query and format for ChatGPT
                    const results: Array<{
                        id: string;
                        title: string;
                        text: string;
                        url?: string;
                    }> = [];

                    if (result.data?.publishedDatasources?.[0]?.fields) {
                        const fields = result.data.publishedDatasources[0].fields;
                        const searchTerm = query.toLowerCase();

                        const filteredFields = fields.filter((field: any) => {
                            const name = field.name?.toLowerCase() || '';
                            const description = field.description?.toLowerCase() || '';
                            const fullyQualifiedName = field.fullyQualifiedName?.toLowerCase() || '';

                            return (
                                name.includes(searchTerm) ||
                                description.includes(searchTerm) ||
                                fullyQualifiedName.includes(searchTerm)
                            );
                        });

                        // Format results for ChatGPT's expected format
                        filteredFields.forEach((field: any, index: number) => {
                            results.push({
                                id: `field_${index}`,
                                title: field.name || 'Unknown Field',
                                text: `Field: ${field.name || 'Unknown'}\nType: ${field.dataType || 'Unknown'}\nRole: ${field.role || 'Unknown'}\nDescription: ${field.description || 'No description available'}\nFully Qualified Name: ${field.fullyQualifiedName || 'Unknown'}`,
                            });
                        });
                    }

                    return new Ok({
                        results,
                    });
                },
            });
        },
    });

    return searchTool;
}; 